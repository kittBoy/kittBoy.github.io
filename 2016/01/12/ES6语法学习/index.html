<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ES6语法学习 | 蓝色天空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ES6语法学习</h1><a id="logo" href="/.">蓝色天空</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ES6语法学习</h1><div class="post-meta">Jan 12, 2016<span> | </span><span class="category"><a href="/categories/js/">js</a><a href="/categories/js/es6/">es6</a></span></div><div class="post-content"><h3 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h3><h4 id="let和const命令-1"><a href="#let和const命令-1" class="headerlink" title="let和const命令"></a>let和const命令</h4><ol>
<li>let只在命令所在的代码块内有效。</li>
<li>不存在变量提升。</li>
<li>暂时性死区</li>
<li>不允许重复声明<h4 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h4></li>
<li>声明一个只读常量。一旦声明常量值就不能改变。</li>
</ol>
<p>注意：es6规定，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令，const命令，class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。</p>
<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><ol>
<li>结构赋值本质上属于模式比配，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</li>
<li>结构赋值允许指定默认的值。</li>
<li>只要某种数据结构具有Iterator接口，度可以采用数组形式的解构赋值。</li>
</ol>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><ol>
<li>对象的解构赋值与数组有一个重要的不同。数据的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取得正确的值。</li>
<li>对象的解构赋值内部机制，是先找到同名属性，然后再赋值给对应的变量。真正被赋值的是后者，而不是前者。</li>
</ol>
<h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><ol>
<li>字符串也可以结构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</li>
</ol>
<h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h4><ol>
<li>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</li>
<li>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对他们进行解构赋值，都会报错.</li>
</ol>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><h5 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h5><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<h5 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h5><ol>
<li>变量声明语句中不能带有圆括号.</li>
<li>函数参数中,模式不能带有圆括号.</li>
<li>赋值语句中,不能讲整个模式,或嵌套模式中的一层,放在圆括号之中.</li>
</ol>
<h5 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h5><ol>
<li>可以使用圆括号的情况只有一种:赋值语句的非模式部分,可以使用圆括号。</li>
</ol>
<p>用途</p>
<ol>
<li>交换变量的值</li>
<li>从函数返回多个值。</li>
<li>函数参数的定义</li>
<li>提取json数据</li>
<li>函数参数的默认值。</li>
<li>遍历Map结构</li>
<li>输入模块的指定方法</li>
</ol>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><ol>
<li>字符的Unicode表示法。</li>
<li>codePointAt()，能够正确处理4个字节存储的字符，返回一个字符的码点。</li>
<li>String.fromCodePoint()用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符<br>注意：fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</li>
<li>字符串的遍历器接口，使得字符串可以被for…of循环遍历。</li>
<li>at()字符串实例的at方法，可以识别Unicode编号大于）0xFFFF的字符，返回正确的字符。</li>
<li>normalize()，将字符的不同表示方法统一为同样的形式，这称为Unicode的正规化.不过，normalize方法目前不能识别三个火三个以上字符的合成。这种情况下，还是只能用正则表达式，通过Unicode编号区间来判断。</li>
<li>includes(),startsWith(),endsWith()</li>
<li>repeat()方法返回一个新字符串，表示将原字符串重复n次。</li>
<li>padStart(),padEnd()ES7推出了字符串不全长度的功能。如果某个字符串不能指定长度，会在头部和尾部不全。padStart用于头部补全，padEnd用于尾部补全。</li>
<li>模板字符串，是增强版的字符串，用反引号标识。它可以当作普通字符串使用，也可以使用定义多行字符串，或者在字符串中嵌入变量。</li>
<li>标签模板，模板字符串可以紧跟在一个函数名后面吗，该函数将被调用来处理这个模板字符串。这被称为标签模板功能。</li>
<li>String.raw()ES6还为原生的String对象，提供了一个raw方法。用来充当模板字符串的处理函数，返回一个斜杠都被转义的字符串，对应于替换变量后的模板字符串。</li>
</ol>
<h3 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h3><ol>
<li>RegExp构造函数，如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</li>
<li>字符串的正则表达式，字符串对象共有4个方法，可以使用正则表达式：match(),replace(),search()和split()。ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全部定义在RegExp对象上。</li>
<li>U修饰符ES6对正则表达式添加了u修饰符，含义为Unicode模式，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</li>
<li>ES6新增了y修饰符，叫做粘连sticky修饰符y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</li>
<li>sticky属性，与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。<br>ES6为表达式新增了flags属性，会返回正则表达式的修饰符。</li>
<li>RegExp.escape()</li>
</ol>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><ol>
<li>二进制和八进制表示法,ES6提供了二进制和八进制数值的新的写法，分别用前缀0B或0b和0o或0O</li>
<li>ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。Number.isFinite()用来检查一个数值是否为有限的（finite）。Number.isNaN()用来检查一个值是否为NaN。</li>
<li>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</li>
<li>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</li>
<li>ES6在Number对象上面，新增一个极小的常量Number.EPSILON。实现误差检测机制。</li>
<li>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</li>
<li>指数运算 **</li>
</ol>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><ol>
<li>Array.from()方法用于将两类对象转为真正的数组：类数组对象和可遍历的对象(包括ES6新增的数据结构Set和Map)</li>
<li>Array.of()方法用于将一组值，转换为数组。</li>
<li>数组实例的copyWithin()方法，在当前数组内部，将指定为哈子的成员复制到其他为哈子，然后返回当前数组。会修改当前数组。</li>
<li>数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。</li>
<li>数组实例的fill方法使用给定的值，填充一个数组。</li>
<li>数组实例的entries(),keys()和values()用于遍历数组，他们都返回一个便利器对象，可以用for…of循环进行遍历。</li>
<li>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，于字符串的includes方法类似。该方法属于ES7,但Babel转码器已经支持。</li>
<li>数组的空位。ES6明确将空位转为undefined.</li>
</ol>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><ol>
<li>函数参数的默认值</li>
<li>rest参数</li>
<li>扩展运算符</li>
</ol>
<ul>
<li>合并数组</li>
<li>与解构复制结合</li>
<li>函数的返回值</li>
<li>字符串</li>
<li>实现了Iterator接口的对象</li>
<li>Map和Set结构，Generator函数</li>
</ul>
<ol start="4">
<li>函数的name属性，返回该函数的函数名</li>
<li>箭头函数</li>
<li>函数绑定</li>
<li>尾部调用优化</li>
</ol>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><ol>
<li>属性的简写表示法</li>
<li>属性名表达式</li>
<li>方法的name属性，返回对象名。</li>
<li>Object.is()比较两个值是否相等</li>
<li>Object.assign()方法用于对象的合并。注意（浅拷贝）</li>
<li>属性的可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</li>
<li>属性的遍历</li>
</ol>
<ul>
<li>for…in 自身和继承可枚举</li>
<li>Object.keys(obj)自身可枚举</li>
<li>Object.getOwnPropertyNames(Obj)自身所有属性</li>
<li>Object.getOwnPropertySybols(obj)包含对象自身的所有Symbol属性</li>
<li>Reflect.ownKeys(obj) 对象自身所有属性，不管属性名是否是Symbol或字符串，也不管是否可枚举。</li>
</ul>
<ol start="8">
<li>proto属性，Object.setPrototypeOf(),Object.getPrototypeOf()</li>
<li>Object.values(),Object.entries()</li>
<li>对象的扩展运算符</li>
</ol>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><h3 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h3><ol>
<li>Proxy支持的拦截操作</li>
</ol>
<ul>
<li>get</li>
<li>set</li>
<li>has</li>
<li>deleteProperty</li>
<li>ownKeys</li>
<li>getOwnPropertyNames</li>
<li>getOwnPropertyDescriptor</li>
<li>defineProperty</li>
<li>preventExtensions</li>
<li>getPrototypeOf</li>
<li>isExtensible</li>
<li>setPrototypeOf</li>
<li>apply</li>
<li>construct</li>
</ul>
<ol start="2">
<li>Reflect</li>
</ol>
<ul>
<li>get</li>
<li>set</li>
<li>has</li>
<li>deleteProperty</li>
<li>ownKeys</li>
<li>getOwnPropertyNames</li>
<li>getOwnPropertyDescriptor</li>
<li>defineProperty</li>
<li>preventExtensions</li>
<li>getPrototypeOf</li>
<li>isExtensible</li>
<li>setPrototypeOf</li>
<li>apply</li>
<li>construct</li>
</ul>
<h3 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h3><ol>
<li>ArrayBuffer对象</li>
<li>TypeArray视图</li>
<li>DataView视图</li>
</ol>
<h3 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h3><ol>
<li>Set，类似于数组，但是成员值都是唯一的，没有重复的值。</li>
<li>WeakSet,成员只能是对象，而不能是其他类型的值。其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</li>
<li>Map</li>
<li>WeakMapWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</li>
</ol>
<h3 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h3><ol>
<li>Iterator遍历器</li>
<li>数据结构默认的Iterator接口，ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是可便利的iterable。调用Symbol.iterator方法，就会得到当前数据结构默认的遍历器生成函数。Symbol.iterator本身就是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的，类型为Symbol的特殊值，所以要放在方括号内。</li>
</ol>
<ul>
<li>ES6中，有三类数据结构原生具备Iterator接口：数组，某些类似数组的对象，Set和Map结构。</li>
</ul>
<ol start="3">
<li>调用Iterator接口的场合</li>
</ol>
<ul>
<li>解构赋值</li>
<li>扩展运算符</li>
<li>yield*</li>
<li>其他场合</li>
</ul>
<ol start="4">
<li>字符串的Iterator接口</li>
<li>Iterator接口和Generator函数</li>
<li>遍历器对象的retur(),throw()</li>
<li>for…of循环</li>
</ol>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><ol>
<li>应用</li>
</ol>
<ul>
<li>异步操作的同步化表达</li>
<li>控制流管理</li>
<li>部署iterator接口</li>
<li>作为数据结构</li>
</ul>
<h3 id="异步操作和Async函数"><a href="#异步操作和Async函数" class="headerlink" title="异步操作和Async函数"></a>异步操作和Async函数</h3><ol>
<li>Generator函数</li>
<li>Thunk函数</li>
<li>co模块</li>
<li>async函数</li>
</ol>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><ol>
<li>Class的继承</li>
<li>Class的Generaotr方法</li>
<li>Class的静态方法</li>
<li>Class的静态属性和实例属性</li>
<li>new.target属性</li>
<li>Mixin模式的实现</li>
</ol>
<h3 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h3><ol>
<li>类的修饰</li>
<li>类的方法的修饰</li>
<li>Mixin</li>
<li>Trait</li>
</ol>
<h3 id="Moudle"><a href="#Moudle" class="headerlink" title="Moudle"></a>Moudle</h3></div><div class="tags"><a href="/tags/js/">js</a><a href="/tags/es6/">es6</a></div><div class="post-nav"><a class="pre" href="/2016/06/10/ckeditor 插件机制中用到的设计模式/">ckeditor 插件机制中用到的设计模式</a><a class="next" href="/2015/05/12/git常用命令/">git常用命令</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://kittboy.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/FE/">FE</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/FE/CSS/">CSS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js/ckeditor/">ckeditor</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/es6/">es6</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/ckeditor/" style="font-size: 15px;">ckeditor</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/FE/" style="font-size: 15px;">FE</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/10/ckeditor 概览/">ckeditor 概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/07/ckeditor引导程序/">ckeditor引导程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/ckeditor插件机制/">ckeditor插件机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/ckeditor 事件机制与发布订阅模式/">ckeditor 事件机制与发布订阅模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/10/ckeditor 插件机制中用到的设计模式/">ckeditor 插件机制中用到的设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/12/ES6语法学习/">ES6语法学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/12/git常用命令/">git常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/15/移动端无缝适配的几种实现方式/">移动端无缝适配的几种实现方式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蓝色天空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>